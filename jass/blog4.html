<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Async/Await Explained - JASS</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/blog-post.css">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="container">
            <div class="logo">JASS</div>
            <ul class="nav-links">
                <li><a href="index.html#home">Home</a></li>
                <li><a href="index.html#blog">Blog</a></li>
                <li><a href="index.html#about">About</a></li>
                <li><a href="index.html#contact">Contact</a></li>
            </ul>
        </div>
    </nav>

    <!-- Blog Post Content -->
    <article class="blog-post-container">
        <div class="container">
            <div class="blog-post-header">
                <h1>JavaScript Async/Await Explained</h1>
                <p class="post-meta">Published on <strong>February 1, 2026</strong> | By <strong>JASS Team</strong></p>
            </div>

            <div class="blog-post-content">
                <p>Async/await is one of the most important features in modern JavaScript. It provides a cleaner way to handle asynchronous operations compared to callbacks and promises. In this guide, we'll explore everything you need to know about async/await.</p>

                <h2>Understanding Asynchronous Programming</h2>
                <p>In JavaScript, some operations take time to complete (like fetching data from an API, reading files, or database queries). Asynchronous programming allows your code to continue executing while these operations run in the background.</p>

                <h2>Evolution: Callbacks → Promises → Async/Await</h2>

                <h3>The Callback Approach (Old)</h3>
                <p>Early JavaScript used callbacks, which can lead to "callback hell":</p>
                <pre><code>function fetchUserData(userId, callback) {
    setTimeout(() => {
        callback({ id: userId, name: "John" });
    }, 1000);
}

fetchUserData(1, function(user) {
    console.log("User:", user);
    fetchUserData(user.id, function(nextUser) {
        console.log("Next User:", nextUser);
        // This gets messy quickly...
    });
});</code></pre>

                <h3>The Promise Approach</h3>
                <p>Promises made this cleaner:</p>
                <pre><code>function fetchUserData(userId) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve({ id: userId, name: "John" });
        }, 1000);
    });
}

fetchUserData(1)
    .then(user => {
        console.log("User:", user);
        return fetchUserData(user.id);
    })
    .then(nextUser => console.log("Next User:", nextUser))
    .catch(error => console.error("Error:", error));</code></pre>

                <h3>The Async/Await Approach (Best)</h3>
                <p>Async/await is the cleanest and most readable:</p>
                <pre><code>async function getUserData() {
    try {
        const user = await fetchUserData(1);
        console.log("User:", user);
        
        const nextUser = await fetchUserData(user.id);
        console.log("Next User:", nextUser);
    } catch (error) {
        console.error("Error:", error);
    }
}

getUserData();</code></pre>

                <h2>What is Async?</h2>
                <p>The <code>async</code> keyword declares an asynchronous function. It automatically returns a promise:</p>
                <pre><code>async function myFunction() {
    return "Hello";
}

// This is equivalent to:
myFunction().then(result => console.log(result)); // "Hello"</code></pre>

                <h2>What is Await?</h2>
                <p>The <code>await</code> keyword pauses execution until a promise is resolved. It can only be used inside an async function:</p>
                <pre><code>async function fetchData() {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    return data;
}</code></pre>

                <h2>Real-World Example: Fetching Data</h2>
                <pre><code>async function loadUserProfile(userId) {
    try {
        // Fetch user data
        const userResponse = await fetch(`/api/users/${userId}`);
        const user = await userResponse.json();
        
        // Fetch user posts
        const postsResponse = await fetch(`/api/users/${userId}/posts`);
        const posts = await postsResponse.json();
        
        // Update UI
        displayUserProfile(user, posts);
    } catch (error) {
        console.error("Failed to load user profile:", error);
        displayErrorMessage("Unable to load user profile");
    }
}

loadUserProfile(123);</code></pre>

                <h2>Error Handling with Async/Await</h2>

                <h3>Using Try/Catch</h3>
                <pre><code>async function safeOperation() {
    try {
        const result = await riskyAsyncOperation();
        console.log("Success:", result);
    } catch (error) {
        console.error("Error:", error.message);
    } finally {
        console.log("Operation completed");
    }
}</code></pre>

                <h3>Handling Multiple Errors</h3>
                <pre><code>async function handleMultipleRequests() {
    try {
        const user = await fetchUser();
        const posts = await fetchPosts();
        const comments = await fetchComments();
        
        return { user, posts, comments };
    } catch (error) {
        if (error.name === "NetworkError") {
            console.error("Network connection failed");
        } else {
            console.error("Unknown error:", error);
        }
    }
}</code></pre>

                <h2>Parallel vs Sequential Execution</h2>

                <h3>Sequential (One After Another)</h3>
                <pre><code>async function sequential() {
    const user = await fetchUser();      // 1 second
    const posts = await fetchPosts();    // 1 second
    // Total: 2 seconds
}</code></pre>

                <h3>Parallel (At the Same Time)</h3>
                <pre><code>async function parallel() {
    const [user, posts] = await Promise.all([
        fetchUser(),
        fetchPosts()
    ]);
    // Total: 1 second (both run simultaneously)
}</code></pre>

                <h2>Common Patterns</h2>

                <h3>Pattern 1: Retrying Failed Operations</h3>
                <pre><code>async function fetchWithRetry(url, maxRetries = 3) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(url);
            if (response.ok) return response;
        } catch (error) {
            if (i === maxRetries - 1) throw error;
            await sleep(1000 * (i + 1)); // Exponential backoff
        }
    }
}</code></pre>

                <h3>Pattern 2: Timeout Handling</h3>
                <pre><code>function withTimeout(promise, ms) {
    return Promise.race([
        promise,
        new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Timeout')), ms)
        )
    ]);
}

const data = await withTimeout(fetchData(), 5000);</code></pre>

                <h2>Important Tips</h2>
                <ul>
                    <li>Await can only be used inside async functions</li>
                    <li>Use <code>Promise.all()</code> for parallel operations</li>
                    <li>Always handle errors with try/catch</li>
                    <li>Don't create unnecessary async functions if they don't need await</li>
                    <li>Be careful with loops and async/await (use Promise.all if appropriate)</li>
                </ul>

                <h2>Browser and Node.js Support</h2>
                <p>Async/await is supported in all modern browsers and Node.js 7.6+. If you need to support older environments, use a transpiler like Babel.</p>

                <h2>Conclusion</h2>
                <p>Async/await has revolutionized asynchronous programming in JavaScript. It makes code more readable and easier to maintain compared to callbacks and promise chains. Master async/await and you'll write cleaner, more efficient asynchronous code!</p>

                <div class="blog-navigation">
                    <a href="index.html#blog" class="back-link">← Back to Blog</a>
                </div>
            </div>
        </div>
    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>&copy; 2026 JASS Blog. All rights reserved.</p>
        </div>
    </footer>

    <script src="js/script.js"></script>
</body>
</html>
